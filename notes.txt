1tick = 10ms
互斥信号量特性比计数信号量多
任务优先级从0-31，tconfig.h文件
任务切换（上下文切换）是由PendSV中断进行的。因为临界区关中断，所以退出临界区后发生切换。
任务延时：将任务从就绪队列移出，加入延时队列。
每个任务有自己的程序计数器，被调度回来时会在被调度离开的地方继续执行。
21
链表的第一个任务是运行任务，后面的是就绪任务。没有运行列表。
23
任务2强制删除任务1；任务4请求删除任务3，任务3自己删除自己。
延时任务不可能调用函数删除自己。能够要求删除自己的任务一定是currentTask。
25
事件控制块——实现信号量，消息队列，。。。，消息标志
实现的必要性：
1. 同步两个任务的运行；
2. 处理多个任务共享资源的冲突问题（之前用关中断、调度锁）；
3. 在多个任务之间传递消息通信；
4. 在中断ISR与任务之间传递多个事件标志。
两大核心功能：任务进入事件控制块等待，发送事件给控制块恢复任务运行。
26
事件控制块的等待与通知：任务进入事件控制块等待队列中暂停运行，、
事件发送时通知任务从任务队列移除继续运行。
为任务添加"等待状态"，提供以下服务：
1. 任务等待事件，进入等待队列
2. 唤醒任务，从事件控制块唤醒，移出等待队列，（调度算法）
3. 将任务强制从事件控制块删除
4. 时钟节拍处理中添加等待超时处理逻辑
    任务如果有延时并且在等待某事件控制块，强制从事件控制块等待队列移除
27
事件控制块的清空：将任务从事件的等待队列中移除，插入就绪队列。-》 唤醒全部
事件控制块的状态查询：返回事件控制块中任务等待数
29
P操作 wait操作，判断计数>0：是  计数器-1，任务消耗资源返回
		                否 任务进入事件等待队列，事件调度。事件发生恢复运行，返回
V操作 notify操作，判断是否有任务等待：是  取首个等待的任务唤醒，比较与当前任务的优先级决定是否调度，返回
		                               否 计数+1，任务返还资源，判断计数值是否合理，返回
30
信号量的删除：释放等待队列，将计数器值置0，在作业中不涉及内存管理。完成后需要进行一次任务调度，响应从
队列中移出的高优先级任务，让其根据等待返回结果继续运行。
信号量的状态查询：与任务的状态查询类型，通过一个新的结构体传递信息。
31
通过邮箱在多个任务间传递消息
邮箱 = 事件控制块 + 消息缓存队列（环形读写缓冲区）
邮箱中的消息缓存队列和等待消息的任务队列不同时为空
32
邮箱的获取：消息被拿走（消息被任务获取）；邮箱的释放：消息到达邮箱（消息被任务释放给邮箱）。
消息到达邮箱，等待队列有任务直接给。任务前往邮箱，消息缓存队列有消息直接拿。
使用数组实现环形读写缓冲区。（可通过读索引-1后使用读索引写入实现高优先级消息优先读取）
notifyOption指定更高优先级的消息
33
邮箱的清空只清空消息缓存区，事件控制块中的等待队列不用管
邮箱的删除只清空事件控制块中的等待队列
35
malloc、free任意大小内存空间 -》产生内存碎片  代码实现复杂 时间不定
RTOS中的内存分配需求
1 从程序底层往上到应用层，所有东西开发都是完全可见的
2 针对特定场合开发，有时存储空间分配大小的种类只有有限种
存储块的数据结构：
1 事件控制块
2 存储块的首地址
3 每个存储块的大小
4 总的存储块个数
5 （空闲）存储块列表
初始化过程：将所有存储块链接到存储块列表
存储块的大小要作为链表结点，而这个结点会占有存储块大小，因此存储块大小有下限。
36
获取存储块（有等待和无等待）：有空闲存储块时直接获取，否则进入事件的等待队列。等待结束后从tTask->eventMsg取出存储块
释放存储块：等待队列有任务给任务，否则插入存储块列表
还的时候向尾巴还，取的时候从头取
测试代码中task2，wait资源但没有notify，使得最终无存储块可wait
37
存储块的删除：将事件控制块的等待队列中的任务全部删除。
                       空闲存储块列表不用管，因为非动态分配内存，存储块处于删除状态
38
事件标志组
结构：事件控制块 + flags事件标志，事件控制块等待队列中的任务同时持有一个等待标志集合
39
事件标志组的等待与通知
事件标志组等待：没有任务等待，事件发生则设置相应的标志位，否则遍历等待列表，唤醒满足任务
等待事件标志：条件不满足加入等待队列，条件满足则直接返回（并归位，由TFLAGGROUP_CONSUME宏控制）
通知事件标志：事件发生时，如没有任务等待，则设置相应的标志位，否则遍历等待列表，唤醒满足了的任务
置位事件：置0事件clear，置1事件set。无论哪种事件相应位都用1表示标志产生
通知事件发生的逻辑：判断置1事件还是清零事件；遍历所有的等待任务，获取满足条件的任务，加入到待移除队列
40
事件标志组的删除：将等待的任务列表删除，不用管标志位，因为标志组不会再使用
41
互斥信号量，与计数器的不同 
解决问题：多个任务共享资源：1.关中断 2. 调度锁（任务调度被终止）3. 计数信号量 4. 互斥信号量
使用计数信号量存在的不足：1. 不支持嵌套 2. 不支持所有者，任何人都能notify 3. 无法解决优先级反转问题
结构：
1. 事件控制块：任务等待队列
2. 锁定计数器：支持嵌套，初值为0，每次锁定则+1，释放信号量-1，减为0从等待队列释放占有
3. 信号量拥有者指针
4. 拥有者原始优先级
42
等待互斥信号量：   1. 信号量未被占有（锁定计数器<= 0）：拥有者指向任务，锁定计数器+1
                              2. 被自己占有：锁定计数器+1 
                              3. 已被高优先级任务占有：加入等待队列
                              4. 已被低优先级任务占有：插入等待队列，（优先级继承）将此低优先级任务的优先级设置成高优先级一样
释放信号量  1. 拥有者不是当前任务：返回错误
                   2. 锁定计数器<= 0：直接退出
                   3. 锁定计数器-1后大于0： 说明还没到最终释放的时候，直接退出
                   4. 减了之后为0：
                      1. 未发生优先级继承：将信号量释放，从等待队列唤醒任务，唤醒的任务占有信号量，判断优先级并调度
                      2. 发生了：将低优先级任务释放并改回原始优先级，唤醒等待队列任务，唤醒的任务占有信号量
43
与计数信号量原理类似
删除：(相当于恢复初态)未被锁定时删除，清空等待队列。如果未发生优先级继承：要先恢复优先级
查询：新建结构体：等待的任务数量、拥有者的优先级（最开始的）、继承优先级（继承之后的）、拥有者、锁定次数
44
软定时器：硬件定时器数量有限
指定周期运行或指定时间运行一次
软定时器状态：创建、启动、正在执行回调函数、停止、销毁
45
两个列表维护所有的定时器
将定时器插入列表：硬定时器列表：在时钟节拍中断中访问（临界区）
	              软定时器列表：在信号量上访问
等待信号量获取列表占有权
等待信号量获取系统节拍中断
假设定时器的启动和停止被任务调用，整个定时器模板作为一个任务，在任务上调度执行，其优先级必须高于空闲任务
46
删除和状态查询：和之前的相同
47
每个任务都配备一个有限的任务栈，用于保存各种关键数据。可能溢出 
统计堆栈剩余空闲空间的字节大小
48
测量CPU使用百分比：1. 找出低效的代码的 2. 发现系统异常 。。。。
统计原理：单位时间CPU分别有多少时间在执行应用任务代码和空闲任务代码
49
内核裁剪：用条件编译指令控制某些代码是否编译
可具体到对函数进行裁剪
50
Hooks扩展，钩子函数，用于在某些内核代码中插入一个占位。
当执行到该位置时，执行自定义的功能代码（实现在内核外部），避免直接修改原始的内核代码。
可扩展更多功能的钩子函数
51
实际硬件设备测试时，逻辑分析仪没用
keil提供工程标准，因此方便移植
其他RTOS内核上移植需要根据具体内核芯片特性修改PendSV中断，任务初始化